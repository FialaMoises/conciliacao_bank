/**
 * StreamingManager - Sistema avan√ßado de streaming SSE para Concilia√ß√£o Banc√°ria
 * Implementa interface moderna com estados visuais e reconex√£o autom√°tica
 */

class StreamingManager {
    constructor(apiUrl, containerId = 'progressSection') {
        this.apiUrl = apiUrl;
        this.container = document.getElementById(containerId);
        this.eventSource = null;
        this.state = 'IDLE';
        this.sessionId = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 3;
        this.reconnectDelay = 2000; // 2 segundos

        // Dados de streaming
        this.streamingData = {
            progress: 0,
            currentStep: '',
            results: {
                conciliated: [],
                suggested: [],
                pending: [],
                no_correlation: [],
                unmatched_mongo: []
            },
            counters: {
                conciliated: 0,
                suggested: 0,
                pending: 0,
                no_correlation: 0,
                unmatched_mongo: 0
            },
            events: []
        };

        this.states = {
            IDLE: 'idle',
            UPLOADING: 'uploading',
            VALIDATING: 'validating',
            STREAMING: 'streaming',
            RESULTS: 'results',
            ERROR: 'error',
            CONNECTION_LOST: 'connection-lost',
            RECONNECTING: 'reconnecting'
        };

        // Event handlers completos para todos os tipos de eventos SSE + novos eventos granulares
        this.eventHandlers = {
            'file_uploaded': this.handleFileUploadedEvent.bind(this),
            'file_validated': this.handleFileValidatedEvent.bind(this),
            'extracting_transactions': this.handleExtractingEvent.bind(this),
            'transactions_extracted': this.handleExtractedEvent.bind(this),
            'file_analysis_complete': this.handleFileAnalysisCompleteEvent.bind(this),
            'loading_mongo_data': this.handleLoadingMongoEvent.bind(this),
            'mongo_data_loaded': this.handleMongoLoadedEvent.bind(this),
            'processing_matches': this.handleProcessingMatchesEvent.bind(this),
            'matches_processed': this.handleMatchesProcessedEvent.bind(this),
            'llm_analysis_complete': this.handleLLMAnalysisEvent.bind(this),
            'reconciliation_complete': this.handleReconciliationCompleteEvent.bind(this),
            'error': this.handleErrorEvent.bind(this),
            // Novos handlers para progresso em tempo real
            'transaction_progress': this.handleTransactionProgressEvent.bind(this),
            'processing_progress': this.handleProcessingProgressEvent.bind(this),
            // Novos handlers granulares para concilia√ß√£o ao vivo
            'transaction_processing': this.handleTransactionProcessingEvent.bind(this),
            'match_found': this.handleMatchFoundEvent.bind(this),
            'counter_update': this.handleCounterUpdateEvent.bind(this),
            'batch_processed': this.handleBatchProcessedEvent.bind(this),
            // Manter handlers antigos para compatibilidade
            'progress': this.handleProgressEvent.bind(this),
            'complete': this.handleCompleteEvent.bind(this)
        };

        // Controle de throttling para atualiza√ß√µes em tempo real
        this.lastCounterUpdate = 0;
        this.throttleInterval = 100; // M√°ximo 10 atualiza√ß√µes por segundo
        this.pendingCounterUpdates = {};

        this.init();
    }

    init() {
        console.log('üåä StreamingManager initialized');
        this.setupEventListeners();
    }

    /**
     * Inicia o streaming com upload direto via SSE endpoint
     */
    async startStreaming(formData) {
        try {
            this.setState(this.states.UPLOADING);
            this.resetStreamingData();

            console.log('üöÄ Starting streaming upload...');

            // Fazer upload direto para o endpoint SSE
            const response = await fetch(`${this.apiUrl}/stream/reconcile`, {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Erro no upload');
            }

            // Obter session ID do header
            this.sessionId = response.headers.get('X-Session-ID') || 'session_' + Date.now();
            console.log('üÜî Session ID:', this.sessionId);

            this.setState(this.states.STREAMING);

            // Processar response stream diretamente
            await this.processResponseStream(response);

        } catch (error) {
            console.error('‚ùå Erro durante streaming:', error);
            this.handleError(error.message);
        }
    }

    /**
     * Processa response stream do fetch diretamente
     */
    async processResponseStream(response) {
        if (!response.body) {
            console.error('‚ùå Response n√£o possui body stream');
            return;
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let eventCount = 0;
        let lastEventTime = Date.now();

        console.log('üåä Iniciando processamento de stream...');
        this.updateConnectionStatus('connected');

        // Timer para detectar perda de eventos
        const eventTimeoutCheck = setInterval(() => {
            const now = Date.now();
            if (now - lastEventTime > 30000 && eventCount === 0) { // 30 segundos sem eventos
                console.warn('‚ö†Ô∏è Nenhum evento SSE recebido em 30 segundos');
                console.log('üîç DEBUG - Status da stream:', {
                    eventCount,
                    lastEventTime: new Date(lastEventTime).toISOString(),
                    bufferLength: buffer.length
                });
            }
        }, 15000);

        try {
            while (true) {
                const { done, value } = await reader.read();

                if (done) {
                    console.log(`‚úÖ Stream conclu√≠do - Total de eventos processados: ${eventCount}`);
                    break;
                }

                // Decodificar chunk
                const chunk = decoder.decode(value, { stream: true });
                buffer += chunk;

                console.log(`üîç DEBUG - Chunk recebido (${chunk.length} chars):`, chunk.substring(0, 200) + (chunk.length > 200 ? '...' : ''));

                // Processar eventos SSE completos
                const events = buffer.split('\n\n');
                buffer = events.pop() || ''; // Manter √∫ltima linha incompleta no buffer

                for (const eventBlock of events) {
                    if (eventBlock.trim()) {
                        console.log(`üîç DEBUG - Processando evento #${eventCount + 1}:`, eventBlock.substring(0, 150) + (eventBlock.length > 150 ? '...' : ''));
                        this.parseSSEBlock(eventBlock);
                        eventCount++;
                        lastEventTime = Date.now();
                    }
                }
            }

            // Processar buffer restante se houver
            if (buffer.trim()) {
                console.log('üîç DEBUG - Processando buffer restante:', buffer);
                this.parseSSEBlock(buffer);
                eventCount++;
            }

        } catch (error) {
            console.error('‚ùå Erro ao processar stream:', error);
            this.updateConnectionStatus('error');
            throw error;
        } finally {
            clearInterval(eventTimeoutCheck);
            reader.releaseLock();
        }
    }

    /**
     * Parseia um bloco de evento SSE
     */
    parseSSEBlock(eventBlock) {
        try {
            // Extrair linha de dados
            const lines = eventBlock.split('\n');
            const dataLine = lines.find(line => line.startsWith('data: '));

            if (!dataLine) {
                console.log('üîç Bloco SSE sem dados:', eventBlock);
                return;
            }

            // Extrair JSON
            const jsonData = dataLine.substring(6).trim(); // Remove "data: "
            if (!jsonData) return;

            const eventData = JSON.parse(jsonData);
            console.log('üì° Evento SSE parseado:', eventData);

            // Processar evento
            this.processSSEEvent(eventData);

        } catch (error) {
            console.error('‚ùå Erro ao parsear bloco SSE:', error, eventBlock);
        }
    }

    /**
     * Processa evento SSE individual
     */
    processSSEEvent(eventData) {
        try {
            console.log('üì° Processando evento SSE:', eventData);

            // Adicionar evento ao log visual
            this.addEventToLog(eventData);

            // Processar evento com handler espec√≠fico
            const handler = this.eventHandlers[eventData.type];
            if (handler) {
                console.log(`‚öôÔ∏è Executando handler para: ${eventData.type}`);
                handler(eventData);
            } else {
                console.log(`üì° Evento n√£o mapeado: ${eventData.type}`, eventData);
                // Fallback para handler gen√©rico
                this.handleGenericEvent(eventData);
            }

        } catch (error) {
            console.error('‚ùå Erro ao processar evento SSE:', error, eventData);
        }
    }

    /**
     * Handler para eventos de progresso
     */
    handleProgressEvent(eventData) {
        const { progress, step, message } = eventData;

        // Atualizar dados de progresso
        this.streamingData.progress = progress || 0;
        this.streamingData.currentStep = step || '';

        // Atualizar UI
        this.updateProgressBar(this.streamingData.progress);
        this.updateStepIndicator(step);
        this.updateProgressMessage(message || step);

        // Atualizar contadores se dispon√≠vel
        if (eventData.conciliated_count !== undefined) {
            this.updateCounters({
                conciliated: eventData.conciliated_count,
                suggested: eventData.suggested_count || 0,
                pending: eventData.pending_count || 0
            });
        }

        // Log detalhado
        const progressPercent = Math.round(this.streamingData.progress * 100);
        console.log(`üìä Progresso: ${progressPercent}% - ${step}: ${message}`);
    }

    /**
     * Handler para evento de conclus√£o
     */
    handleCompleteEvent(eventData) {
        console.log('üéâ Streaming conclu√≠do!', eventData);

        this.setState(this.states.RESULTS);
        this.updateProgressBar(1.0);
        this.updateProgressMessage('Concilia√ß√£o conclu√≠da com sucesso!');

        // Atualizar contadores finais
        if (eventData.summary) {
            this.updateCounters(eventData.summary);
        }

        // Buscar resultado completo
        if (this.sessionId) {
            setTimeout(() => {
                this.fetchCompleteResults();
            }, 1000);
        }
    }

    /**
     * Handler para eventos de erro
     */
    handleErrorEvent(eventData) {
        console.error('‚ùå Erro SSE recebido:', eventData);

        this.setState(this.states.ERROR);
        this.showError(eventData.error || 'Erro durante processamento');

        if (eventData.details) {
            console.error('Detalhes do erro:', eventData.details);
        }
    }

    /**
     * Busca resultado completo da sess√£o
     */
    async fetchCompleteResults() {
        try {
            console.log('üîç Buscando resultado completo da sess√£o:', this.sessionId);

            const response = await fetch(`${this.apiUrl}/stream/session/${this.sessionId}/result`);
            const data = await response.json();

            if (data.success && data.result) {
                this.streamingData.results = data.result;
                this.displayResults(data.result);
                console.log('üìä Resultado completo carregado');
            } else {
                console.error('‚ùå Erro ao obter resultado:', data.error);
            }
        } catch (error) {
            console.error('‚ùå Erro ao buscar resultado:', error);
        }
    }

    /**
     * Exibe resultados usando fun√ß√£o existente
     */
    displayResults(result) {
        console.log('üìä Preparando exibi√ß√£o de resultados:', result);

        // Compatibilidade com sistema existente
        const compatibleResult = {
            ...result,
            summary: {
                conciliated_count: result.conciliated?.length || 0,
                suggested_count: result.suggested?.length || 0,
                pending_count: result.pending?.length || 0,
                no_correlation_count: result.no_correlation?.length || 0,
                unmatched_mongo_count: result.unmatched_mongo?.length || 0
            },
            result: result
        };

        console.log('üìä Resultado compat√≠vel preparado:', compatibleResult);

        // Atualizar contadores finais
        this.updateCounters(compatibleResult.summary);

        // Usar fun√ß√£o existente se dispon√≠vel
        if (typeof showResults === 'function') {
            console.log('‚úÖ Chamando showResults existente');

            // Definir currentResults global para compatibilidade
            if (typeof window !== 'undefined') {
                window.currentResults = compatibleResult;
            }

            showResults(compatibleResult);
        } else {
            console.warn('‚ö†Ô∏è Fun√ß√£o showResults n√£o encontrada, usando fallback');
            this.fallbackDisplayResults(compatibleResult);
        }
    }

    /**
     * Fallback para exibi√ß√£o de resultados se showResults n√£o existir
     */
    fallbackDisplayResults(result) {
        // Mostrar se√ß√£o de resultados
        const resultsSection = document.getElementById('resultsSection');
        if (resultsSection) {
            resultsSection.style.display = 'block';
            console.log('‚úÖ Se√ß√£o de resultados exibida');
        }

        // Esconder progresso
        this.hideProgress();

        // Log dos resultados
        console.log('üìä Resultados da concilia√ß√£o:', {
            conciliated: result.summary.conciliated_count,
            suggested: result.summary.suggested_count,
            pending: result.summary.pending_count,
            no_correlation: result.summary.no_correlation_count,
            unmatched_mongo: result.summary.unmatched_mongo_count
        });
    }

    /**
     * Gerencia estados visuais
     */
    setState(newState) {
        const oldState = this.state;
        this.state = newState;

        console.log(`üîÑ Estado: ${oldState} ‚Üí ${newState}`);

        this.updateUI();
        this.updateStateIndicators();
    }

    /**
     * Atualiza interface baseado no estado
     */
    updateUI() {
        if (!this.container) return;

        // Atualizar classes CSS
        this.container.className = `progress-section state-${this.state}`;

        switch (this.state) {
            case this.states.IDLE:
                this.hideProgress();
                break;
            case this.states.UPLOADING:
                this.showProgress();
                this.updateProgressMessage('Enviando arquivo...');
                this.updateProgressBar(0.05);
                break;
            case this.states.VALIDATING:
                this.updateProgressMessage('Validando arquivo...');
                this.updateProgressBar(0.1);
                break;
            case this.states.STREAMING:
                this.showProgressInterface();
                break;
            case this.states.RESULTS:
                this.showResultsInterface();
                break;
            case this.states.ERROR:
                this.showErrorInterface();
                break;
            case this.states.CONNECTION_LOST:
                this.showReconnectInterface();
                break;
            case this.states.RECONNECTING:
                this.showReconnectingInterface();
                break;
        }
    }

    /**
     * Mostra interface de progresso
     */
    showProgress() {
        if (this.container) {
            this.container.style.display = 'block';
        }
    }

    /**
     * Esconde interface de progresso
     */
    hideProgress() {
        if (this.container) {
            this.container.style.display = 'none';
        }
    }

    /**
     * Atualiza barra de progresso
     */
    updateProgressBar(progress) {
        // Tentar m√∫ltiplos IDs para compatibilidade
        const progressFill = document.getElementById('progressFill') ||
                            document.querySelector('.progress-fill') ||
                            document.querySelector('#progressFill');

        if (progressFill) {
            const percent = Math.round(progress * 100);
            progressFill.style.width = `${percent}%`;

            // Adicionar anima√ß√£o
            progressFill.style.transition = 'width 0.4s cubic-bezier(0.4, 0, 0.2, 1)';

            // Adicionar classe de anima√ß√£o se n√£o existir
            if (!progressFill.classList.contains('streaming-progress')) {
                progressFill.classList.add('streaming-progress');
            }

            console.log(`üìä Progresso atualizado: ${percent}%`);
        } else {
            console.error('‚ùå Elemento progressFill n√£o encontrado!');
            console.log('üîç DEBUG - Elementos dispon√≠veis:', {
                getElementById: document.getElementById('progressFill'),
                querySelector1: document.querySelector('.progress-fill'),
                querySelector2: document.querySelector('#progressFill'),
                allProgress: document.querySelectorAll('[id*="progress"]')
            });
        }
    }

    /**
     * Atualiza mensagem de progresso
     */
    updateProgressMessage(message) {
        // Tentar m√∫ltiplos seletores para compatibilidade
        const progressText = document.getElementById('progressText') ||
                            document.querySelector('.progress-text') ||
                            document.querySelector('#progressText');

        if (progressText) {
            progressText.textContent = message;
            console.log(`üí¨ Mensagem: ${message}`);
        } else {
            console.warn('‚ö†Ô∏è Elemento progressText n√£o encontrado');
            // Fallback: mostrar no console
            console.log(`üìù ${message}`);
        }
    }

    /**
     * Atualiza indicador de etapa
     */
    updateStepIndicator(currentStep) {
        // Mapeamento de etapas
        const stepMapping = {
            'file_uploaded': 0,
            'file_validated': 1,
            'extracting_transactions': 2,
            'transactions_extracted': 2,
            'loading_system_data': 3,
            'system_data_loaded': 3,
            'starting_reconciliation': 4,
            'processing_matches': 4,
            'analyzing_duplicates': 5,
            'finalizing_results': 6,
            'results_ready': 7
        };

        const currentIndex = stepMapping[currentStep] || 0;

        // Se tiver interface de steps, atualizar
        const steps = document.querySelectorAll('.step-indicator');
        steps.forEach((step, index) => {
            if (index <= currentIndex) {
                step.classList.add('completed');
                step.classList.remove('active');
            } else if (index === currentIndex + 1) {
                step.classList.add('active');
                step.classList.remove('completed');
            } else {
                step.classList.remove('active', 'completed');
            }
        });
    }

    /**
     * Atualiza contadores din√¢micos
     */
    updateCounters(counters) {
        // Mapeamento correto para os IDs que existem no HTML
        const elementMapping = {
            // Mapear dados do backend para elementos HTML existentes
            'total_transactions': ['extractedCount'],
            'conciliated_count': ['matchesCount'], // Usar matches para conciliadas
            'suggested_count': ['processedCount'], // Usar processed para sugeridas temporariamente
            'pending_count': ['processedCount'], // Mapear para processed tamb√©m
            'no_correlation_count': ['processedCount'], // Mapear para processed
            'unmatched_mongo_count': ['processedCount'], // Mapear para processed
            'processed_count': ['processedCount'],
            'extracted_count': ['extractedCount'],
            'matches_count': ['matchesCount'],
            'uploaded_count': ['uploadedCount']
        };

        Object.keys(counters).forEach(key => {
            const possibleIds = elementMapping[key] || [`${key}Count`];
            let element = null;

            // Tentar encontrar o elemento com diferentes IDs
            for (const id of possibleIds) {
                element = document.getElementById(id);
                if (element) break;
            }

            if (element) {
                const oldValue = parseInt(element.textContent) || 0;
                const newValue = counters[key] || 0;

                element.textContent = newValue;

                // Adicionar classe de anima√ß√£o
                if (!element.classList.contains('counter-number')) {
                    element.classList.add('counter-number');
                }

                // Anima√ß√£o se valor mudou
                if (newValue !== oldValue) {
                    element.classList.add('updated');
                    setTimeout(() => element.classList.remove('updated'), 600);
                    console.log(`üî¢ Contador ${key}: ${oldValue} ‚Üí ${newValue}`);
                }
            } else {
                console.warn(`‚ö†Ô∏è Contador ${key} n√£o encontrado (IDs tentados: ${possibleIds.join(', ')})`);
            }
        });

        // Atualizar dados internos
        this.streamingData.counters = { ...this.streamingData.counters, ...counters };
    }

    /**
     * Adiciona evento ao log
     */
    addEventToLog(eventData) {
        const logEvent = {
            timestamp: new Date(),
            type: eventData.type,
            message: eventData.message || eventData.step,
            data: eventData
        };

        this.streamingData.events.push(logEvent);

        // Manter apenas √∫ltimos 50 eventos
        if (this.streamingData.events.length > 50) {
            this.streamingData.events.shift();
        }
    }

    /**
     * Mostra erro
     */
    showError(message) {
        console.error('‚ùå Erro:', message);

        const errorSection = document.getElementById('errorSection');
        const errorMessage = document.getElementById('errorMessage');

        if (errorSection && errorMessage) {
            errorMessage.textContent = message;
            errorSection.style.display = 'block';
        }

        this.hideProgress();
    }

    /**
     * Manipula erro geral
     */
    handleError(message) {
        this.setState(this.states.ERROR);
        this.showError(message);
    }

    /**
     * Reset dados de streaming
     */
    resetStreamingData() {
        this.streamingData = {
            progress: 0,
            currentStep: '',
            results: {
                conciliated: [],
                suggested: [],
                pending: [],
                no_correlation: [],
                unmatched_mongo: []
            },
            counters: {
                conciliated: 0,
                suggested: 0,
                pending: 0,
                no_correlation: 0,
                unmatched_mongo: 0
            },
            events: []
        };
    }

    /**
     * Configura event listeners
     */
    setupEventListeners() {
        // Listener para limpeza quando p√°gina √© fechada
        window.addEventListener('beforeunload', () => {
            this.disconnect();
        });
    }

    /**
     * Desconecta streaming
     */
    disconnect() {
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
        }
        this.setState(this.states.IDLE);
        console.log('üîå Streaming desconectado');
    }

    /**
     * Obt√©m status atual
     */
    getStatus() {
        return {
            state: this.state,
            sessionId: this.sessionId,
            progress: this.streamingData.progress,
            currentStep: this.streamingData.currentStep,
            counters: this.streamingData.counters,
            eventsCount: this.streamingData.events.length
        };
    }

    /**
     * Interface de progresso melhorada
     */
    showProgressInterface() {
        // Implementa√ß√£o espec√≠fica se necess√°rio
        // Por enquanto, usar elementos existentes
    }

    /**
     * Interface de resultados
     */
    showResultsInterface() {
        // Mostrar se√ß√£o de resultados
        const resultsSection = document.getElementById('resultsSection');
        if (resultsSection) {
            resultsSection.style.display = 'block';
        }
        this.hideProgress();
    }

    /**
     * Interface de erro
     */
    showErrorInterface() {
        this.showError('Erro durante processamento');
    }

    /**
     * Interface de reconex√£o
     */
    showReconnectInterface() {
        this.updateProgressMessage('Conex√£o perdida. Tentando reconectar...');
    }

    /**
     * Interface de reconectando
     */
    showReconnectingInterface() {
        this.updateProgressMessage(`Reconectando... (tentativa ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
    }

    /**
     * Atualiza indicadores de estado
     */
    updateStateIndicators() {
        // Atualizar indicador de API status se existir
        const apiStatus = document.getElementById('apiStatus');
        if (apiStatus) {
            const icon = apiStatus.querySelector('i');
            const text = apiStatus.querySelector('span');

            if (this.state === this.states.STREAMING) {
                if (icon) icon.className = 'fas fa-circle streaming';
                if (text) text.textContent = 'Processando...';
            } else if (this.state === this.states.CONNECTION_LOST) {
                if (icon) icon.className = 'fas fa-circle offline';
                if (text) text.textContent = 'Desconectado';
            } else {
                if (icon) icon.className = 'fas fa-circle online';
                if (text) text.textContent = 'Online';
            }
        }
    }

    // ============================================================================
    // NOVOS EVENT HANDLERS ESPEC√çFICOS PARA TODOS OS 11 TIPOS DE EVENTOS SSE
    // ============================================================================

    /**
     * Handler: file_uploaded - Arquivo foi enviado com sucesso
     */
    handleFileUploadedEvent(eventData) {
        console.log('üì§ Arquivo enviado:', eventData);
        this.updateProgressBar(0.1);
        this.updateProgressMessage('Arquivo enviado com sucesso');
        this.updateStepIndicator(0); // Upload step
        this.updateCounter('uploadedCount', 1);
    }

    /**
     * Handler: file_validated - Arquivo foi validado
     */
    handleFileValidatedEvent(eventData) {
        console.log('‚úÖ Arquivo validado:', eventData);
        this.updateProgressBar(0.15);
        this.updateProgressMessage('Arquivo validado');
        this.updateStepIndicator(1); // An√°lise step

        if (eventData.file_format) {
            console.log(`üìÑ Formato detectado: ${eventData.file_format}`);
        }
    }

    /**
     * Handler: extracting_transactions - Iniciando extra√ß√£o de transa√ß√µes
     */
    handleExtractingEvent(eventData) {
        console.log('üîç Extraindo transa√ß√µes:', eventData);
        this.updateProgressBar(0.25);
        this.updateProgressMessage('Extraindo transa√ß√µes do arquivo...');
        this.updateStepIndicator(2); // Extra√ß√£o step
    }

    /**
     * Handler: transactions_extracted - Transa√ß√µes extra√≠das
     */
    handleExtractedEvent(eventData) {
        console.log('üî• === HANDLER: transactions_extracted ===');
        console.log('üìã Dados recebidos:', eventData);
        console.log('üîç DEBUG - Dados completos do evento:', JSON.stringify(eventData, null, 2));

        this.updateProgressBar(0.35);

        // M√∫ltiplas tentativas para encontrar o count com debugging detalhado
        const possibleCounts = {
            transaction_count: eventData.transaction_count,
            count: eventData.count,
            total_transactions: eventData.total_transactions,
            extracted_count: eventData.extracted_count,
            data_count: eventData.data && eventData.data.count,
        };

        console.log('üîç DEBUG - Poss√≠veis valores de count:', possibleCounts);

        const count = eventData.transaction_count ||
                     eventData.count ||
                     eventData.total_transactions ||
                     eventData.extracted_count ||
                     (eventData.data && eventData.data.count) ||
                     0;

        console.log(`üî¢ Count final detectado: ${count} (tipo: ${typeof count})`);

        this.updateProgressMessage(`${count} transa√ß√µes extra√≠das`);

        // SEMPRE tentar atualizar o contador, mesmo se count for 0
        console.log(`üìä === FOR√áANDO ATUALIZA√á√ÉO DE EXTRACTEDCOUNT ===`);
        console.log(`üìä Valor a ser definido: ${count}`);

        // Verificar se elemento existe ANTES de atualizar
        const element = document.getElementById('extractedCount');
        console.log(`üìä Elemento extractedCount encontrado:`, element ? `SIM (valor atual: "${element.textContent}")` : 'N√ÉO');

        this.updateCounter('extractedCount', count);

        // Verificar se a atualiza√ß√£o funcionou
        setTimeout(() => {
            const elementAfter = document.getElementById('extractedCount');
            if (elementAfter) {
                const newValue = elementAfter.textContent;
                console.log(`üìä VERIFICA√á√ÉO: extractedCount ap√≥s atualiza√ß√£o = "${newValue}"`);
                if (String(newValue) !== String(count)) {
                    console.error(`‚ùå ERRO: Contador n√£o foi atualizado corretamente! Esperado: ${count}, Atual: ${newValue}`);
                } else {
                    console.log(`‚úÖ SUCESSO: Contador atualizado corretamente para ${count}`);
                }
            }
        }, 100);

        // Fallback: se count for 0 mas temos dados, tentar extrair de outras formas
        if (count === 0 && eventData) {
            console.log('‚ö†Ô∏è Count √© 0, tentando alternativas...');

            // Verificar se h√° array de transa√ß√µes
            if (eventData.transactions && Array.isArray(eventData.transactions)) {
                const arrayCount = eventData.transactions.length;
                console.log(`üìà Encontrado array com ${arrayCount} transa√ß√µes`);
                this.updateCounter('extractedCount', arrayCount);
            }

            // Verificar se h√° mensagem com n√∫mero
            const messageMatch = (eventData.message || '').match(/(\d+)/);
            if (messageMatch) {
                const numberFromMessage = parseInt(messageMatch[1]);
                console.log(`üîç N√∫mero encontrado na mensagem: ${numberFromMessage}`);
                this.updateCounter('extractedCount', numberFromMessage);
            }
        }

        // Se temos dados detalhados, come√ßar a popular a an√°lise do arquivo
        if (eventData.file_format || eventData.bank_detected) {
            this.showFileAnalysis();

            // Atualizar informa√ß√µes b√°sicas do arquivo
            if (eventData.file_format) {
                this.updateAnalysisValue('fileFormat', eventData.file_format);
            }
            if (eventData.bank_detected) {
                this.updateAnalysisValue('bankDetected', eventData.bank_detected);
            }
            if (eventData.file_size_mb) {
                this.updateAnalysisValue('fileSize', `${eventData.file_size_mb} MB`);
            }
            if (eventData.date_range) {
                this.updateAnalysisValue('dateRange', eventData.date_range);
            }

            // Atualizar estat√≠sticas financeiras
            if (eventData.expenses_count !== undefined) {
                this.updateFinancialData({
                    expenses_count: eventData.expenses_count,
                    incomes_count: eventData.incomes_count,
                    total_amount: eventData.total_amount
                });
            }
        }
    }

    /**
     * Handler: file_analysis_complete - An√°lise do arquivo conclu√≠da
     */
    handleFileAnalysisCompleteEvent(eventData) {
        console.log('üìä An√°lise do arquivo conclu√≠da:', eventData);
        this.updateProgressBar(0.35);
        this.updateProgressMessage('An√°lise do arquivo conclu√≠da');

        // Mostrar se√ß√£o de an√°lise se ainda n√£o estiver vis√≠vel
        this.showFileAnalysis();

        // Processar estat√≠sticas completas se dispon√≠veis
        if (eventData.statistics) {
            const stats = eventData.statistics;

            // Atualizar informa√ß√µes b√°sicas
            this.updateAnalysisValue('fileFormat', stats.format || 'N√£o identificado');
            this.updateAnalysisValue('bankDetected', stats.bank_detected || 'N√£o identificado');
            this.updateAnalysisValue('dateRange', stats.date_range || 'N√£o dispon√≠vel');
            this.updateAnalysisValue('fileSize', `${stats.size_mb || 0} MB`);

            // Atualizar dados financeiros completos
            this.updateFinancialData({
                expenses_count: stats.expenses_count || 0,
                incomes_count: stats.incomes_count || 0,
                expenses_amount: stats.total_expenses || 0,
                incomes_amount: stats.total_incomes || 0,
                total_amount: stats.total_amount || 0
            });

            console.log('‚úÖ Estat√≠sticas do arquivo atualizadas:', stats);
        }
    }

    /**
     * Handler: loading_mongo_data - Carregando dados do MongoDB
     */
    handleLoadingMongoEvent(eventData) {
        console.log('üóÑÔ∏è Carregando MongoDB:', eventData);
        this.updateProgressBar(0.45);
        this.updateProgressMessage('Carregando dados do sistema...');
        this.updateStepIndicator(3); // MongoDB step
    }

    /**
     * Handler: mongo_data_loaded - Dados do MongoDB carregados
     */
    handleMongoLoadedEvent(eventData) {
        console.log('üìä Dados MongoDB carregados:', eventData);
        this.updateProgressBar(0.55);
        this.updateProgressMessage(`${eventData.count || 0} documentos carregados`);

        if (eventData.count) {
            console.log(`üìà ${eventData.count} documentos do sistema carregados`);
        }
    }

    /**
     * Handler: processing_matches - Processando correspond√™ncias
     */
    handleProcessingMatchesEvent(eventData) {
        console.log('üîÑ Processando matches:', eventData);
        this.updateProgressBar(0.65);

        // Atualizar contador processado se dispon√≠vel
        if (eventData.current_transaction && eventData.total_transactions) {
            this.updateCounter('processedCount', eventData.current_transaction);
            this.updateProgressMessage(`Processando transa√ß√£o ${eventData.current_transaction}/${eventData.total_transactions}...`);
        } else if (eventData.processed_count !== undefined) {
            this.updateCounter('processedCount', eventData.processed_count);
            this.updateProgressMessage(`${eventData.processed_count} transa√ß√µes processadas...`);
        } else {
            this.updateProgressMessage('Processando correspond√™ncias...');
        }

        this.updateStepIndicator(4); // Processamento step
    }

    /**
     * Handler: matches_processed - Correspond√™ncias processadas
     */
    handleMatchesProcessedEvent(eventData) {
        console.log('‚ú® Matches processados:', eventData);
        this.updateProgressBar(0.75);

        // Atualizar m√∫ltiplos contadores se dispon√≠vel
        const counters = {};

        if (eventData.matches_count !== undefined) {
            counters.matchesCount = eventData.matches_count;
        }

        if (eventData.processed_count !== undefined) {
            counters.processedCount = eventData.processed_count;
        }

        if (eventData.total_processed !== undefined) {
            counters.processedCount = eventData.total_processed;
        }

        // Atualizar contadores se houver dados
        if (Object.keys(counters).length > 0) {
            Object.entries(counters).forEach(([id, value]) => {
                this.updateCounter(id, value);
            });
        }

        // Mensagem personalizada baseada nos dados dispon√≠veis
        if (eventData.processed_count && eventData.total_transactions) {
            this.updateProgressMessage(`${eventData.processed_count}/${eventData.total_transactions} transa√ß√µes processadas`);
        } else if (eventData.matches_count) {
            this.updateProgressMessage(`${eventData.matches_count} correspond√™ncias identificadas`);
        } else {
            this.updateProgressMessage('Correspond√™ncias identificadas');
        }
    }

    /**
     * Handler: llm_analysis_complete - An√°lise LLM conclu√≠da
     */
    handleLLMAnalysisEvent(eventData) {
        console.log('üß† An√°lise LLM conclu√≠da:', eventData);
        this.updateProgressBar(0.85);
        this.updateProgressMessage('An√°lise inteligente conclu√≠da');
        this.updateStepIndicator(5); // LLM step
    }

    /**
     * Handler: reconciliation_complete - Concilia√ß√£o conclu√≠da
     */
    handleReconciliationCompleteEvent(eventData) {
        console.log('üéâ Concilia√ß√£o conclu√≠da:', eventData);
        this.updateProgressBar(1.0);
        this.updateProgressMessage('Concilia√ß√£o conclu√≠da com sucesso!');
        this.updateStepIndicator(7); // Resultados step

        // Atualizar contadores finais
        if (eventData.summary) {
            this.updateFinalCounters(eventData.summary);
        }

        // Mudar para estado de resultados
        this.setState(this.states.RESULTS);

        // Buscar e exibir resultados
        setTimeout(() => {
            if (eventData.result) {
                this.displayResults(eventData.result);
            } else {
                this.fetchCompleteResults();
            }
        }, 500);
    }

    /**
     * Handler gen√©rico para eventos n√£o mapeados
     */
    handleGenericEvent(eventData) {
        console.log('üîÑ Evento gen√©rico:', eventData);

        // Tentar extrair progresso gen√©rico
        if (eventData.progress !== undefined) {
            this.updateProgressBar(eventData.progress);
        }

        // Tentar extrair mensagem gen√©rica
        if (eventData.message || eventData.step) {
            this.updateProgressMessage(eventData.message || eventData.step);
        }
    }

    /**
     * Atualiza contador individual com anima√ß√£o
     */
    updateCounter(counterId, value) {
        console.log(`üîç [DEBUG] Tentando atualizar contador ${counterId} para ${value}`);
        console.log(`üîç [DEBUG] Tipo do valor: ${typeof value}`);

        const counter = document.getElementById(counterId);
        console.log(`üîç [DEBUG] Elemento encontrado:`, counter ? `Sim (${counter.tagName})` : 'N√£o');

        if (counter) {
            const oldValue = parseInt(counter.textContent) || 0;
            const newValue = parseInt(value) || 0;

            console.log(`üîç [DEBUG] Valores: oldValue=${oldValue}, newValue=${newValue}`);

            if (newValue !== oldValue) {
                counter.textContent = newValue;
                counter.classList.add('counter-updated');
                setTimeout(() => counter.classList.remove('counter-updated'), 600);
                console.log(`‚úÖ [DEBUG] Contador ${counterId}: ${oldValue} ‚Üí ${newValue} ‚ú®`);

                // Verificar se a atualiza√ß√£o realmente aconteceu
                setTimeout(() => {
                    const checkValue = parseInt(counter.textContent) || 0;
                    if (checkValue === newValue) {
                        console.log(`‚úÖ [DEBUG] Confirmado: ${counterId} = ${checkValue}`);
                    } else {
                        console.error(`‚ùå [DEBUG] ERRO: ${counterId} deveria ser ${newValue} mas √© ${checkValue}`);
                    }
                }, 100);

            } else {
                console.log(`‚ÑπÔ∏è [DEBUG] Contador ${counterId} j√° tem valor ${newValue}, sem altera√ß√£o`);
            }
        } else {
            console.error(`‚ùå [DEBUG] Contador ${counterId} n√£o encontrado!`);
            console.log('üîç [DEBUG] Contadores dispon√≠veis:',
                Array.from(document.querySelectorAll('[id*="Count"]')).map(el => `${el.id} (${el.textContent})`)
            );

            // Tentar encontrar elementos similares
            const similar = document.querySelectorAll(`[id*="${counterId.replace('Count', '')}"]`);
            if (similar.length > 0) {
                console.log('üîç [DEBUG] Elementos similares encontrados:',
                    Array.from(similar).map(el => `${el.id} (${el.tagName})`)
                );
            }
        }
    }

    /**
     * Atualiza contadores finais
     */
    updateFinalCounters(summary) {
        console.log('üìä Atualizando contadores finais:', summary);

        // Usar IDs corretos que existem no HTML
        const counterMapping = {
            extractedCount: summary.total_transactions || summary.extracted_count || 0,
            processedCount: summary.total_transactions || summary.processed_count || 0,
            matchesCount: summary.conciliated_count || summary.matches_count || 0,
            uploadedCount: 1 // Sempre 1 arquivo processado
        };

        console.log('üîç DEBUG - Mapeamento final dos contadores:', counterMapping);

        Object.entries(counterMapping).forEach(([id, value]) => {
            console.log(`üéØ Atualizando contador final: ${id} = ${value}`);
            this.updateCounter(id, value);
        });
    }

    /**
     * Atualiza status de conex√£o
     */
    updateConnectionStatus(status) {
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');

        if (statusDot && statusText) {
            statusDot.className = `status-dot ${status}`;

            const statusMessages = {
                connected: 'Conectado',
                connecting: 'Conectando...',
                error: 'Erro de Conex√£o',
                reconnecting: 'Reconectando...'
            };

            statusText.textContent = statusMessages[status] || 'Desconhecido';
            console.log(`üîó Status de conex√£o: ${status}`);
        }
    }

    /**
     * Tentativa de reconex√£o
     */
    attemptReconnection() {
        if (this.reconnectAttempts >= this.maxReconnectAttempts) {
            console.error('‚ùå M√°ximo de tentativas de reconex√£o atingido');
            this.setState(this.states.ERROR);
            this.updateConnectionStatus('error');
            return;
        }

        this.reconnectAttempts++;
        this.setState(this.states.RECONNECTING);
        this.updateConnectionStatus('reconnecting');

        const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1); // Exponential backoff

        console.log(`üîÑ Tentativa de reconex√£o ${this.reconnectAttempts}/${this.maxReconnectAttempts} em ${delay}ms`);

        setTimeout(() => {
            this.cleanup();
            // Tentar reconectar (implementa√ß√£o futura)
        }, delay);
    }

    /**
     * Handler: transaction_progress - Progresso individual de transa√ß√£o
     */
    handleTransactionProgressEvent(eventData) {
        console.log('üîÑ Progresso de transa√ß√£o:', eventData);

        // Atualizar contador processado
        if (eventData.current !== undefined) {
            this.updateCounter('processedCount', eventData.current);
        }

        // Mensagem de progresso detalhada
        if (eventData.current && eventData.total) {
            this.updateProgressMessage(`Processando transa√ß√£o ${eventData.current}/${eventData.total}`);

            // Calcular progresso baseado na transa√ß√£o atual
            const progressPercent = (eventData.current / eventData.total) * 0.15 + 0.65; // Entre 65% e 80%
            this.updateProgressBar(progressPercent);
        }

        // Atualizar outros contadores se dispon√≠vel
        if (eventData.matches_found !== undefined) {
            this.updateCounter('matchesCount', eventData.matches_found);
        }
    }

    /**
     * Handler: processing_progress - Progresso geral de processamento
     */
    handleProcessingProgressEvent(eventData) {
        console.log('üìä Progresso de processamento:', eventData);

        // Atualizar m√∫ltiplos contadores
        const counters = {};

        if (eventData.processed_count !== undefined) {
            counters.processedCount = eventData.processed_count;
        }

        if (eventData.matches_count !== undefined) {
            counters.matchesCount = eventData.matches_count;
        }

        // Aplicar atualiza√ß√µes
        if (Object.keys(counters).length > 0) {
            Object.entries(counters).forEach(([id, value]) => {
                this.updateCounter(id, value);
            });
        }

        // Atualizar progresso geral se dispon√≠vel
        if (eventData.progress_percent !== undefined) {
            this.updateProgressBar(eventData.progress_percent / 100);
        }

        // Mensagem personalizada
        if (eventData.message) {
            this.updateProgressMessage(eventData.message);
        }
    }

    /**
     * Cleanup da conex√£o SSE
     */
    cleanup() {
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
            console.log('üßπ Conex√£o SSE limpa');
        }
    }

    /**
     * Reset dos dados de streaming
     */
    resetStreamingData() {
        this.streamingData = {
            progress: 0,
            currentStep: '',
            results: {
                conciliated: [],
                suggested: [],
                pending: [],
                no_correlation: [],
                unmatched_mongo: []
            },
            counters: {
                conciliated: 0,
                suggested: 0,
                pending: 0,
                no_correlation: 0,
                unmatched_mongo: 0
            },
            events: []
        };
        console.log('üîÑ Dados de streaming resetados');
    }

    /**
     * Mostra a se√ß√£o de an√°lise do arquivo
     */
    showFileAnalysis() {
        const fileAnalysis = document.getElementById('fileAnalysis');
        if (fileAnalysis && fileAnalysis.style.display === 'none') {
            fileAnalysis.style.display = 'block';
            setTimeout(() => {
                fileAnalysis.classList.add('visible');
            }, 100);
            console.log('üìä Se√ß√£o de an√°lise do arquivo exibida');
        }
    }

    /**
     * Atualiza um valor de an√°lise com anima√ß√£o
     */
    updateAnalysisValue(fieldId, value) {
        const element = document.getElementById(fieldId);
        if (element) {
            const oldValue = element.textContent;
            if (value !== oldValue && value !== '--') {
                element.textContent = value;
                element.classList.add('updated');
                element.closest('.analysis-item')?.classList.add('updated');

                setTimeout(() => {
                    element.classList.remove('updated');
                    element.closest('.analysis-item')?.classList.remove('updated');
                }, 1000);

                console.log(`üìä An√°lise atualizada ${fieldId}: ${oldValue} ‚Üí ${value}`);
            }
        }
    }

    /**
     * Atualiza dados financeiros com formata√ß√£o e anima√ß√µes
     */
    updateFinancialData(data) {
        console.log('üí∞ Atualizando dados financeiros:', data);

        // Atualizar contadores e valores de despesas
        if (data.expenses_count !== undefined) {
            this.updateFinancialElement('expensesCount', data.expenses_count);
        }
        if (data.expenses_amount !== undefined) {
            this.updateFinancialElement('expensesAmount', this.formatCurrency(data.expenses_amount));
        }

        // Atualizar contadores e valores de receitas
        if (data.incomes_count !== undefined) {
            this.updateFinancialElement('incomesCount', data.incomes_count);
        }
        if (data.incomes_amount !== undefined) {
            this.updateFinancialElement('incomesAmount', this.formatCurrency(data.incomes_amount));
        }

        // Atualizar total movimentado
        if (data.total_amount !== undefined) {
            this.updateFinancialElement('totalAmount', this.formatCurrency(data.total_amount));
        }
    }

    /**
     * Atualiza elemento financeiro individual com anima√ß√£o
     */
    updateFinancialElement(elementId, value) {
        const element = document.getElementById(elementId);
        if (element) {
            const oldValue = element.textContent;
            if (String(value) !== oldValue) {
                element.textContent = value;
                element.classList.add('updated');
                element.closest('.financial-item')?.classList.add('updated');

                setTimeout(() => {
                    element.classList.remove('updated');
                    element.closest('.financial-item')?.classList.remove('updated');
                }, 1000);

                console.log(`üí∞ Financeiro atualizado ${elementId}: ${oldValue} ‚Üí ${value}`);
            }
        }
    }

    /**
     * Formatar valor como moeda brasileira
     */
    formatCurrency(value) {
        if (!value || isNaN(value)) return 'R$ 0,00';

        return new Intl.NumberFormat('pt-BR', {
            style: 'currency',
            currency: 'BRL'
        }).format(value);
    }

    /**
     * Debug detalhado do sistema
     */
    enableDebugMode() {
        console.log('üîç STREAMING DEBUG MODE ATIVADO');
        console.log('üìä Estado atual:', this.getStatus());

        // Override dos m√©todos para adicionar logs detalhados
        const originalProcessSSEEvent = this.processSSEEvent.bind(this);
        this.processSSEEvent = (eventData) => {
            console.log('üîç DEBUG - Evento recebido:', {
                type: eventData.type,
                timestamp: eventData.timestamp,
                data: eventData,
                handler: this.eventHandlers[eventData.type] ? 'Encontrado' : 'N√ÉO ENCONTRADO'
            });
            return originalProcessSSEEvent(eventData);
        };

        // Override updateProgressBar para debug
        const originalUpdateProgressBar = this.updateProgressBar.bind(this);
        this.updateProgressBar = (progress) => {
            console.log(`üîç DEBUG - Progress: ${Math.round(progress * 100)}%`);
            return originalUpdateProgressBar(progress);
        };

        // Override updateCounter para debug
        const originalUpdateCounter = this.updateCounter.bind(this);
        this.updateCounter = (counterId, value) => {
            console.log(`üîç DEBUG - Counter ${counterId}: ${value}`);
            return originalUpdateCounter(counterId, value);
        };

        console.log('‚úÖ Debug mode configurado');
    }

    /**
     * Log detalhado do estado interno
     */
    logInternalState() {
        console.log('üìä === ESTADO INTERNO DO STREAMING MANAGER ===');
        console.log('üîÑ Estado:', this.state);
        console.log('üÜî Session ID:', this.sessionId);
        console.log('üìà Progresso:', Math.round(this.streamingData.progress * 100) + '%');
        console.log('üéØ Step atual:', this.streamingData.currentStep);
        console.log('üìä Contadores:', this.streamingData.counters);
        console.log('üìã Eventos registrados:', this.streamingData.events.length);
        console.log('üîó EventSource:', this.eventSource ? 'Ativo' : 'Inativo');
        console.log('üì± Container:', this.container ? 'Encontrado' : 'N√ÉO ENCONTRADO');

        // Log dos handlers dispon√≠veis
        console.log('‚öôÔ∏è Event Handlers:', Object.keys(this.eventHandlers));

        console.log('üìä === FIM DO ESTADO INTERNO ===');
    }

    /**
     * Fun√ß√£o de teste para verificar conectividade SSE
     */
    async testSSEConnection() {
        console.log('üß™ === TESTE DE CONECTIVIDADE SSE ===');

        try {
            // Teste 1: Health check da API
            console.log('1Ô∏è‚É£ Testando health check da API...');
            const healthResponse = await fetch(`${this.apiUrl}/health`);
            console.log('Health response:', healthResponse.status, healthResponse.statusText);

            // Teste 2: Verificar se endpoint de stream existe
            console.log('2Ô∏è‚É£ Testando endpoint de stream...');
            const streamTestResponse = await fetch(`${this.apiUrl}/stream/test`, { method: 'HEAD' });
            console.log('Stream endpoint test:', streamTestResponse.status);

            // Teste 3: Verificar elementos DOM
            console.log('3Ô∏è‚É£ Verificando elementos DOM...');
            const elements = {
                progressSection: document.getElementById('progressSection'),
                extractedCount: document.getElementById('extractedCount'),
                processedCount: document.getElementById('processedCount'),
                matchesCount: document.getElementById('matchesCount')
            };

            Object.entries(elements).forEach(([name, element]) => {
                console.log(`   ${name}: ${element ? `‚úÖ Encontrado (valor: "${element.textContent}")` : '‚ùå N√ÉO ENCONTRADO'}`);
            });

            console.log('‚úÖ Teste de conectividade conclu√≠do');
            return true;

        } catch (error) {
            console.error('‚ùå Erro no teste de conectividade:', error);
            return false;
        }
    }

    /**
     * Simular evento para teste
     */
    simulateTestEvent(eventType = 'transactions_extracted', data = {}) {
        console.log(`üé≠ Simulando evento: ${eventType}`);

        const testEvent = {
            type: eventType,
            transaction_count: data.count || 197,
            message: data.message || 'Evento de teste',
            timestamp: new Date().toISOString(),
            ...data
        };

        console.log('üì° Evento de teste:', testEvent);
        this.processSSEEvent(testEvent);
    }

    // ============================================================================
    // NOVOS EVENT HANDLERS GRANULARES PARA CONCILIA√á√ÉO AO VIVO
    // ============================================================================

    /**
     * Handler: transaction_processing - Processando transa√ß√£o individual
     */
    handleTransactionProcessingEvent(eventData) {
        console.log('‚ö° Processando transa√ß√£o individual:', eventData);

        const { current, total, transaction_id, progress_percent } = eventData;

        // Atualizar mensagem com progresso espec√≠fico
        if (current && total) {
            this.updateProgressMessage(`Processando transa√ß√£o ${current} de ${total}`);

            // Atualizar contador processado em tempo real
            this.updateCounterWithThrottle('processedCount', current);

            // Atualizar progresso baseado na transa√ß√£o atual
            if (progress_percent !== undefined) {
                this.updateProgressBar(progress_percent / 100);
            }
        }

        // Log detalhado
        console.log(`üìä Transa√ß√£o ${current}/${total} sendo processada (ID: ${transaction_id})`);
    }

    /**
     * Handler: match_found - Match encontrado em tempo real
     */
    handleMatchFoundEvent(eventData) {
        console.log('üéØ Match encontrado:', eventData);

        const { transaction_id, match_type, current_matches, total_matches } = eventData;

        // Atualizar contador de matches em tempo real
        if (current_matches !== undefined) {
            this.updateCounterWithThrottle('matchesCount', current_matches);
        }

        // Mostrar feedback visual do match
        this.showMatchFeedback(match_type, transaction_id);

        console.log(`‚úÖ Match ${match_type} encontrado! Total: ${current_matches}`);
    }

    /**
     * Handler: counter_update - Atualiza√ß√£o espec√≠fica de contador
     */
    handleCounterUpdateEvent(eventData) {
        console.log('üìä Atualiza√ß√µes de contadores:', eventData);

        const { counters } = eventData;

        if (counters) {
            Object.entries(counters).forEach(([counterType, value]) => {
                // Mapear tipos de contador para IDs corretos
                const counterMap = {
                    'processed': 'processedCount',
                    'extracted': 'extractedCount',
                    'matches': 'matchesCount',
                    'uploaded': 'uploadedCount'
                };

                const counterId = counterMap[counterType] || `${counterType}Count`;
                this.updateCounterWithThrottle(counterId, value);
            });
        }
    }

    /**
     * Handler: batch_processed - Lote de transa√ß√µes processado
     */
    handleBatchProcessedEvent(eventData) {
        console.log('üì¶ Lote processado:', eventData);

        const { batch_size, total_processed, remaining } = eventData;

        // Atualizar contador geral
        if (total_processed !== undefined) {
            this.updateCounterWithThrottle('processedCount', total_processed);
        }

        // Mensagem informativa
        if (remaining !== undefined) {
            this.updateProgressMessage(`${total_processed} processadas, ${remaining} restantes`);
        }

        console.log(`üìä Lote de ${batch_size} transa√ß√µes processado. Total: ${total_processed}`);
    }

    /**
     * Atualizar contador com throttling para performance
     */
    updateCounterWithThrottle(counterId, value) {
        const now = Date.now();

        // Armazenar √∫ltima atualiza√ß√£o pendente
        this.pendingCounterUpdates[counterId] = value;

        // Verificar se pode atualizar (throttling)
        if (now - this.lastCounterUpdate >= this.throttleInterval) {
            this.flushPendingCounterUpdates();
            this.lastCounterUpdate = now;
        } else {
            // Agendar atualiza√ß√£o se n√£o h√° uma pendente
            if (!this.throttleTimeout) {
                this.throttleTimeout = setTimeout(() => {
                    this.flushPendingCounterUpdates();
                    this.throttleTimeout = null;
                }, this.throttleInterval);
            }
        }
    }

    /**
     * Processar todas as atualiza√ß√µes pendentes de contadores
     */
    flushPendingCounterUpdates() {
        Object.entries(this.pendingCounterUpdates).forEach(([counterId, value]) => {
            this.updateCounterAnimated(counterId, value);
        });

        // Limpar atualiza√ß√µes pendentes
        this.pendingCounterUpdates = {};
    }

    /**
     * Atualizar contador com anima√ß√£o suave
     */
    updateCounterAnimated(counterId, targetValue) {
        const element = document.getElementById(counterId);
        if (!element) {
            console.warn(`‚ö†Ô∏è Contador ${counterId} n√£o encontrado para anima√ß√£o`);
            return;
        }

        const currentValue = parseInt(element.textContent) || 0;
        const difference = targetValue - currentValue;

        // Se diferen√ßa √© pequena, animar incrementalmente
        if (difference > 0 && difference <= 10) {
            this.animateCounterIncrement(element, currentValue, targetValue, 100);
        } else {
            // Atualiza√ß√£o direta para diferen√ßas grandes
            element.textContent = targetValue;
            this.addCounterAnimation(element);
        }

        console.log(`üìä Contador ${counterId}: ${currentValue} ‚Üí ${targetValue}`);
    }

    /**
     * Animar incremento suave de contador
     */
    animateCounterIncrement(element, startValue, endValue, duration) {
        const difference = endValue - startValue;
        const increment = difference / (duration / 16); // ~60fps
        let currentValue = startValue;

        const animate = () => {
            currentValue += increment;

            if (currentValue >= endValue) {
                element.textContent = endValue;
                this.addCounterAnimation(element);
            } else {
                element.textContent = Math.floor(currentValue);
                requestAnimationFrame(animate);
            }
        };

        requestAnimationFrame(animate);
    }

    /**
     * Adicionar anima√ß√£o visual ao contador
     */
    addCounterAnimation(element) {
        element.classList.add('counter-updated', 'counter-pulse');

        setTimeout(() => {
            element.classList.remove('counter-updated', 'counter-pulse');
        }, 600);
    }

    /**
     * Mostrar feedback visual de match encontrado
     */
    showMatchFeedback(matchType, transactionId) {
        // Criar elemento de feedback tempor√°rio
        const feedback = document.createElement('div');
        feedback.className = `match-feedback match-${matchType}`;
        feedback.innerHTML = `
            <i class="fas fa-check-circle"></i>
            <span>Match ${matchType}!</span>
        `;

        // Adicionar ao container de progresso
        const progressSection = document.getElementById('progressSection');
        if (progressSection) {
            progressSection.appendChild(feedback);

            // Remover ap√≥s anima√ß√£o
            setTimeout(() => {
                feedback.remove();
            }, 2000);
        }

        console.log(`üéØ Feedback visual para match ${matchType} (TX: ${transactionId})`);
    }
}

// Export para uso global
window.StreamingManager = StreamingManager;